"use strict";(self.webpackChunkrke_docs=self.webpackChunkrke_docs||[]).push([[5038],{5929:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>p,frontMatter:()=>d,metadata:()=>i,toc:()=>c});var o=r(5893),a=r(1151),t=r(4866),s=r(5162);const d={title:"How Upgrades Work"},l=void 0,i={id:"upgrades/how-upgrades-work/how-upgrades-work",title:"How Upgrades Work",description:"In this section, you'll learn what happens when you edit or upgrade your RKE Kubernetes cluster. The below sections describe how each type of node is upgraded by default when a cluster is upgraded using rke up.",source:"@site/docs/upgrades/how-upgrades-work/how-upgrades-work.md",sourceDirName:"upgrades/how-upgrades-work",slug:"/upgrades/how-upgrades-work/",permalink:"/upgrades/how-upgrades-work/",draft:!1,unlisted:!1,editUrl:"https://github.com/rancher/rke1-docs/edit/main/docs/upgrades/how-upgrades-work/how-upgrades-work.md",tags:[],version:"current",lastUpdatedAt:1704844723,formattedLastUpdatedAt:"Jan 9, 2024",frontMatter:{title:"How Upgrades Work"},sidebar:"mySidebar",previous:{title:"Upgrades",permalink:"/upgrades/"},next:{title:"Maintaining Availability for Applications During Upgrades",permalink:"/upgrades/maintaining-availability/"}},u={},c=[{value:"Upgrades of etcd Nodes",id:"upgrades-of-etcd-nodes",level:3},{value:"Upgrades of Controlplane Nodes",id:"upgrades-of-controlplane-nodes",level:3},{value:"Upgrades of Worker Nodes",id:"upgrades-of-worker-nodes",level:3},{value:"Upgrades of Addons",id:"upgrades-of-addons",level:3},{value:"Upgrades of Controlplane and etcd Nodes",id:"upgrades-of-controlplane-and-etcd-nodes",level:3},{value:"Upgrades of Worker Nodes",id:"upgrades-of-worker-nodes-1",level:3}];function h(e){const n={a:"a",code:"code",h3:"h3",li:"li",ol:"ol",p:"p",ul:"ul",...(0,a.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["In this section, you'll learn what happens when you edit or upgrade your RKE Kubernetes cluster. The below sections describe how each type of node is upgraded by default when a cluster is upgraded using ",(0,o.jsx)(n.code,{children:"rke up"}),"."]}),"\n",(0,o.jsxs)(t.Z,{children:[(0,o.jsxs)(s.Z,{value:"RKE v1.1.0+",children:[(0,o.jsx)(n.p,{children:"The following features are new in RKE v1.1.0:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The ability to upgrade or edit a cluster without downtime for your applications."}),"\n",(0,o.jsx)(n.li,{children:"The ability to manually upgrade nodes of a certain role without upgrading others."}),"\n",(0,o.jsx)(n.li,{children:"The ability to restore a Kubernetes cluster to an older Kubernetes version by restoring it to a snapshot that includes the older Kubernetes version. This capability allows you to safely upgrade one type of node at a time, because if an upgrade cannot be completed by all nodes in the cluster, you can downgrade the Kubernetes version of the nodes that were already upgraded."}),"\n"]}),(0,o.jsxs)(n.p,{children:["When a cluster is upgraded with ",(0,o.jsx)(n.code,{children:"rke up"}),", using the default options, the following process is used:"]}),(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"The etcd plane gets get updated, one node at a time."}),"\n",(0,o.jsx)(n.li,{children:"Controlplane nodes get updated, one node at a time. This includes the controlplane components and worker plane components of the controlplane nodes."}),"\n",(0,o.jsx)(n.li,{children:"Worker plane components of etcd nodes get updated, one node at a time."}),"\n",(0,o.jsx)(n.li,{children:"Worker nodes get updated in batches of a configurable size. The default configuration for the maximum number of unavailable nodes is ten percent, rounded down to the nearest node, with a minimum batch size of one node."}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/config-options/add-ons/",children:"Addons"})," get upgraded one by one."]}),"\n"]}),(0,o.jsx)(n.p,{children:"The following sections break down in more detail what happens when etcd nodes, controlplane nodes, worker nodes, and addons are upgraded. This information is intended to be used to help you understand the update strategy for the cluster, and may be useful when troubleshooting problems with upgrading the cluster."}),(0,o.jsx)(n.h3,{id:"upgrades-of-etcd-nodes",children:"Upgrades of etcd Nodes"}),(0,o.jsx)(n.p,{children:"A cluster upgrade begins by upgrading the etcd nodes one at a time."}),(0,o.jsx)(n.p,{children:"If an etcd node fails at any time, the upgrade will fail and no more nodes will be upgraded. The cluster will be stuck in an updating state and not move forward to upgrading controlplane or worker nodes."}),(0,o.jsx)(n.h3,{id:"upgrades-of-controlplane-nodes",children:"Upgrades of Controlplane Nodes"}),(0,o.jsx)(n.p,{children:"Controlplane nodes are upgraded one at a time by default. The maximum number of unavailable controlplane nodes can also be configured, so that they can be upgraded in batches."}),(0,o.jsx)(n.p,{children:"As long as the maximum unavailable number or percentage of controlplane nodes has not been reached, Rancher will continue to upgrade other controlplane nodes, then the worker nodes."}),(0,o.jsx)(n.p,{children:"If any controlplane nodes were unable to be upgraded, the upgrade will not proceed to the worker nodes."}),(0,o.jsx)(n.h3,{id:"upgrades-of-worker-nodes",children:"Upgrades of Worker Nodes"}),(0,o.jsxs)(n.p,{children:["By default, worker nodes are upgraded in batches. The size of the batch is determined by the maximum number of unavailable worker nodes, configured as the ",(0,o.jsx)(n.code,{children:"max_unavailable_worker"})," directive in the ",(0,o.jsx)(n.code,{children:"cluster.yml"}),"."]}),(0,o.jsxs)(n.p,{children:["By default, the ",(0,o.jsx)(n.code,{children:"max_unavailable_worker"})," nodes is defined as 10 percent of all worker nodes. This number can be configured as a percentage or as an integer. When defined as a percentage, the batch size is rounded down to the nearest node, with a minimum of one node."]}),(0,o.jsxs)(n.p,{children:["For example, if you have 11 worker nodes and ",(0,o.jsx)(n.code,{children:"max_unavailable_worker"})," is 25%, two nodes will be upgraded at once because 25% of 11 is 2.75. If you have two worker nodes and ",(0,o.jsx)(n.code,{children:"max_unavailable_worker"})," is 1%, the worker nodes will be upgraded one at a time because the minimum batch size is one."]}),(0,o.jsxs)(n.p,{children:["When each node in a batch returns to a Ready state, the next batch of nodes begins to upgrade. If ",(0,o.jsx)(n.code,{children:"kubelet"})," and ",(0,o.jsx)(n.code,{children:"kube-proxy"})," have started, the node is Ready. As long as the ",(0,o.jsx)(n.code,{children:"max_unavailable_worker"})," number of nodes have not failed, Rancher will continue to upgrade other worker nodes."]}),(0,o.jsx)(n.p,{children:"RKE scans the cluster before starting the upgrade to find the powered down or unreachable hosts. The upgrade will stop if that number matches or exceeds the maximum number of unavailable nodes."}),(0,o.jsxs)(n.p,{children:["RKE will cordon each node before upgrading it, and uncordon the node afterward. RKE can also be configured to ",(0,o.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/",children:"drain"})," nodes before upgrading them."]}),(0,o.jsxs)(n.p,{children:["RKE will handle all worker node upgrades before upgrading any add-ons. As long as the maximum number of unavailable worker nodes is not reached, RKE will attempt to upgrade the ",(0,o.jsx)(n.a,{href:"#upgrades-of-addons",children:"addons."})," For example, if a cluster has two worker nodes and one worker node fails, but the maximum unavailable worker nodes is greater than one, the addons will still be upgraded."]}),(0,o.jsx)(n.h3,{id:"upgrades-of-addons",children:"Upgrades of Addons"}),(0,o.jsxs)(n.p,{children:["The availability of your applications partly depends on the availability of ",(0,o.jsx)(n.a,{href:"/config-options/add-ons/",children:"RKE addons."})," Addons are used to deploy several cluster components, including network plug-ins, the Ingress controller, DNS provider, and metrics server."]}),(0,o.jsxs)(n.p,{children:["Because RKE addons are necessary for allowing traffic into the cluster, they will need to be updated in batches to maintain availability. You will need to configure the maximum number of unavailable replicas for each addon in the ",(0,o.jsx)(n.code,{children:"cluster.yml"})," to ensure that your cluster will retain enough available replicas during an upgrade."]}),(0,o.jsxs)(n.p,{children:["For more information on configuring the number of replicas for each addon, refer to ",(0,o.jsx)(n.a,{href:"/upgrades/configuring-strategy/",children:"this section."})]}),(0,o.jsxs)(n.p,{children:["For an example showing how to configure the addons, refer to the ",(0,o.jsx)(n.a,{href:"/example-yamls/",children:"example cluster.yml."})]})]}),(0,o.jsxs)(s.Z,{value:"RKE before v1.1.0",children:[(0,o.jsxs)(n.p,{children:["When a cluster is upgraded with ",(0,o.jsx)(n.code,{children:"rke up"}),", using the default options, the following process is used:"]}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"etcd nodes get updated first, one at a time."}),"\n",(0,o.jsx)(n.li,{children:"Controlplane nodes get updated second, in batches of 50 or the total number of worker nodes, whichever is lower."}),"\n",(0,o.jsx)(n.li,{children:"Worker nodes and addons get updated third, in batches of 50 or the total number of worker nodes, whichever is lower."}),"\n",(0,o.jsx)(n.li,{children:"Addons get upgraded one by one."}),"\n"]}),(0,o.jsx)(n.h3,{id:"upgrades-of-controlplane-and-etcd-nodes",children:"Upgrades of Controlplane and etcd Nodes"}),(0,o.jsx)(n.p,{children:"Controlplane and etcd nodes would be upgraded in batches of 50 nodes or the total number of controlplane nodes, whichever is lower."}),(0,o.jsx)(n.p,{children:"If a node fails at any time, the upgrade will stop upgrading any other nodes and fail."}),(0,o.jsx)(n.h3,{id:"upgrades-of-worker-nodes-1",children:"Upgrades of Worker Nodes"}),(0,o.jsx)(n.p,{children:"Worker nodes are upgraded simultaneously, in batches of either 50 or the total number of worker nodes, whichever is lower. If a worker node fails at any time, the upgrade stops."}),(0,o.jsxs)(n.p,{children:["When a worker node is upgraded, it restarts several Docker processes, including the ",(0,o.jsx)(n.code,{children:"kubelet"})," and ",(0,o.jsx)(n.code,{children:"kube-proxy"}),". When ",(0,o.jsx)(n.code,{children:"kube-proxy"})," comes up, it flushes ",(0,o.jsx)(n.code,{children:"iptables"}),". When this happens, pods on this node can\u2019t be accessed, resulting in downtime for the applications."]})]})]})]})}function p(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},5162:(e,n,r)=>{r.d(n,{Z:()=>s});r(7294);var o=r(4334);const a={tabItem:"tabItem_Ymn6"};var t=r(5893);function s(e){let{children:n,hidden:r,className:s}=e;return(0,t.jsx)("div",{role:"tabpanel",className:(0,o.Z)(a.tabItem,s),hidden:r,children:n})}},4866:(e,n,r)=>{r.d(n,{Z:()=>k});var o=r(7294),a=r(4334),t=r(2466),s=r(6550),d=r(469),l=r(1980),i=r(7392),u=r(12);function c(e){return o.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:r}=e;return(0,o.useMemo)((()=>{const e=n??function(e){return c(e).map((e=>{let{props:{value:n,label:r,attributes:o,default:a}}=e;return{value:n,label:r,attributes:o,default:a}}))}(r);return function(e){const n=(0,i.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,r])}function p(e){let{value:n,tabValues:r}=e;return r.some((e=>e.value===n))}function f(e){let{queryString:n=!1,groupId:r}=e;const a=(0,s.k6)(),t=function(e){let{queryString:n=!1,groupId:r}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:n,groupId:r});return[(0,l._X)(t),(0,o.useCallback)((e=>{if(!t)return;const n=new URLSearchParams(a.location.search);n.set(t,e),a.replace({...a.location,search:n.toString()})}),[t,a])]}function g(e){const{defaultValue:n,queryString:r=!1,groupId:a}=e,t=h(e),[s,l]=(0,o.useState)((()=>function(e){let{defaultValue:n,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const o=r.find((e=>e.default))??r[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:t}))),[i,c]=f({queryString:r,groupId:a}),[g,b]=function(e){let{groupId:n}=e;const r=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,t]=(0,u.Nk)(r);return[a,(0,o.useCallback)((e=>{r&&t.set(e)}),[r,t])]}({groupId:a}),m=(()=>{const e=i??g;return p({value:e,tabValues:t})?e:null})();(0,d.Z)((()=>{m&&l(m)}),[m]);return{selectedValue:s,selectValue:(0,o.useCallback)((e=>{if(!p({value:e,tabValues:t}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),b(e)}),[c,b,t]),tabValues:t}}var b=r(2389);const m={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var w=r(5893);function x(e){let{className:n,block:r,selectedValue:o,selectValue:s,tabValues:d}=e;const l=[],{blockElementScrollPositionUntilNextRender:i}=(0,t.o5)(),u=e=>{const n=e.currentTarget,r=l.indexOf(n),a=d[r].value;a!==o&&(i(n),s(a))},c=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const r=l.indexOf(e.currentTarget)+1;n=l[r]??l[0];break}case"ArrowLeft":{const r=l.indexOf(e.currentTarget)-1;n=l[r]??l[l.length-1];break}}n?.focus()};return(0,w.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":r},n),children:d.map((e=>{let{value:n,label:r,attributes:t}=e;return(0,w.jsx)("li",{role:"tab",tabIndex:o===n?0:-1,"aria-selected":o===n,ref:e=>l.push(e),onKeyDown:c,onClick:u,...t,className:(0,a.Z)("tabs__item",m.tabItem,t?.className,{"tabs__item--active":o===n}),children:r??n},n)}))})}function v(e){let{lazy:n,children:r,selectedValue:a}=e;const t=(Array.isArray(r)?r:[r]).filter(Boolean);if(n){const e=t.find((e=>e.props.value===a));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return(0,w.jsx)("div",{className:"margin-top--md",children:t.map(((e,n)=>(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==a})))})}function y(e){const n=g(e);return(0,w.jsxs)("div",{className:(0,a.Z)("tabs-container",m.tabList),children:[(0,w.jsx)(x,{...e,...n}),(0,w.jsx)(v,{...e,...n})]})}function k(e){const n=(0,b.Z)();return(0,w.jsx)(y,{...e,children:c(e.children)},String(n))}},1151:(e,n,r)=>{r.d(n,{Z:()=>d,a:()=>s});var o=r(7294);const a={},t=o.createContext(a);function s(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);